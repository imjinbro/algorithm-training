# 트레이닝 기록 - 하루 1문제라도 꾸준히
# 0426
## 공부한 API, 문법, 생각할 것
* Math.abs(n) : 절대값 리턴
* return 메소드 : 특정조건일 때 리턴한다면 아닐 때에도 리턴해야함
* 배열의 index와 실제 순서 1 차이 있다는 것 꼭 숙지
* 연산자 빼먹지 말자 : (N + 1)(N + 2) 가 아니라 (N + 1) * (N + 2) 다.
* 테스트 돌리기 전에 문법 오류, 머리로 디버깅 런 시키고 디버깅 해보기
* 예외처리 꼭 하기, 데이터 타입 체크하기(저장할 수 있는 범위 - 특히 int와 long)
  * long에 영향을 끼치는 값은 똑같은 long으로 선언해줘야함 : int라면 쓰레기값 던져요
    
* 리턴 타입 체크도 합시다 : 캐스팅이 필요하다면 캐스팅도
  
## 알고리즘 지식
* 데이터 개수에 따른 시간복잡도 제한
  
~~~
• n ˛ 1 000 000 : the expected time complexity is O(n) or O(n log n),
• n ˛ 10 000 : the expected time complexity is O(n2),
• n ˛ 500 : the expected time complexity is O(n3).
~~~

* 공간복잡도 제한
  
~~~
• O(n) : If you need to declare an array with n elements, you have linear space complexity
• O(1) : one variable
~~~
  
## OddOccurrencesInArray
* 페어가 되는 수를 모두 더하면 짝수가 됨 : 그리고 남는게 페어되지않는 숫자
* 페어끼리 빼고 나면 남는 것이 페어되지않는 숫자
* 1회 순회하면서 숫자들을 해당 숫자의 index에 넣어주고 값을 받았을 때 홀수면 페어가 아닌 것으로 : 이러면 최고값을 알고 있어야 그 크기만큼 배열을 만들 수 있는데(for문이 중첩해서 도는게 아니라서 N 혹은 잘 나올 때는 logN까지 나옴 - worstCase 기준 N 그러나 공간복잡도가 꽤나 높은편 100만개까지 나왔을 때 힙 데이터를 100만까지 생성하니 많이 잡아먹는 편)
* 그냥 빠른 정렬 방법으로 소팅해두고, 두개씩 쌍으로 빼주면서 0이 안되었을 때 값을 바로 리턴해주는게 공간 복잡도면에서도 성능상 유리한 편
  * 공간복잡도 조건까지 있다면 공간복잡도까지도 맞춰야...
  * 코드 디자인보다 문제해결을 얼마나 효율적으로 하냐가 중요한 것 같음...
    
## PermMissingElem
* 배열이 주어지는데 1..크기 + 1 범위 숫자가 들어있음, 1개가 빠져있는데 그 숫자를 찾으면 됨
  * 시간복잡도 : O(N) 
  * 공간복잡도 : O(1), 배열 기준 만들었을 때 1개만 들어가야함
  * N개 : 0..100,000 (0일 때는 0을 리턴하도록)
  * 각각 다른 값을 가지고 있음

* 1 ~ N + 1 까지 다 더해놓고 배열에 있는 수를 하나씩 뺴면 나머지 남은 값이 없는 값
  * 굳이 다 N + 1 까지 더할 필요없음 : (N + 1)(1 + N + 1) / 2
  * 범위 잘 보고 long, int 구분하기
  
# 0427
## 공부한 API, 문법, 생각할 것
* 자바 기준 int 범위(4byte) : -2147483648 ~ 2,147,483,647
* 중간값을 가지고 연산을 해야한다면 우선 다 연산해두고 그 값을 가지고 알고리즘에 활용하기
* 문제를 꼼꼼하게 읽자 : 조건, 리턴 무엇, 범위 무엇
  
## 알고리즘 관련
* 예제에 나와있지는 않지만 조건에는 나와있는 예외처리는 반드시해야함
* 실제로 문제 풀 때는 뇌로 디버깅하고 제출할 것
* 초기 쓰레기값을 설정할 때 : 최소 최대인지에 따라 초기 쓰레기값이 어떤 값인지 바뀜
* int, long 범위가 왔다리 갔다리 하는 것에 대해서 생각을 잘하지못함 : 최악의 상황까지 생각해야함(최대, 최소 - 값/개수)
  
## Time Complexity - FrogJmp
* X와 Y, D가 주어짐 : D만큼씩 점프했을 때 X가 Y와 같거나 이상이 되는 값 찾기 
  * 시간복잡도 : O(1), 반복문으로 풀지말고 한번에 어떤 연산에 의해 값을 구하는 문제인듯
  * 공간복잡도 : O(1)
  * 값 범위 : 1..1,000,000,000
     
* 과정값은 모두 다 덜어두고 최종값으로 연산하기
  
## Time Complexity - TapeEquilibrium
* P(인덱스)를 기준으로 배열을 반반냄, 두 배열의 차이가 생김(각각 배열의 합을 구하고 둘을 뺀 후 절대값을 구함) -  (0 ~ P-1) | (P ~ N)까지 그중 가장 작은 차이값을 리턴하면됨
* P는 1부터 ~ N-1(인덱스)까지 진행되어야함 : 그랬을 때 합을 매번?, 최소 차이는 비교해서 바꿔치기하면 될 것 같음
  * 인덱스와 n번째는 구분
  * 새로운 배열 만들어서 인덱스 N까지 합 넣기 : 그리고 꺼내쓰면 되잖, O(N)이다보니 for 2개 중첩하면 안됨, 그때마다 일정범위까지 합을 구하는게 아니라 미리 구해두고 인덱스로 인덱스 N까지의 A[] 요소 합을 바로바로 리턴 받게 만들기
  * 그리고 갈라진 배열에서 뒷구간만 구하려면 뒷구간 - 앞구간 하면 뒤에꺼만 나옴
  
* 시간복잡도 : O(N)
* 공간복잡도 : O(N)
  
* 예제만 맞은 코드
   * int, long 범위가 왔다리 갔다리 하는 것에 대해서 생각을 잘하지못함 : 최악의 상황까지 생각해야함(최대, 최소 - 값/개수)
   * 1000의 숫자가 100,000개 있을 때 최대합 100,000,000 1억이라 int로 처리하는건 상관없음
   * 인덱스랑 n번째를 잘 구분 못함;;;
  
* P를 기준으로 배열을 반으로 가름 : | 0 ~ P-1 | // | P ~ N -1 |, 배열의 길이는 N
  * 1부터 P 설정값의 범위는 N-1까지임
  * 결국 리턴값이 다른거였음;;;;;
  
# 0428
## QuickSort
    
# 0430
## 공부한 API, 문법, 생각할 것
* 순열 : 싱글 엘리먼트는 1개라서 안됩니다
* 문제를 있는 그대로 보기 : 예제가 곧 문제다
* 문제를 꼼꼼하게 보는 연습이 필요하고, 문제를 이해하는 능력을 키워야겠다....
  
## 알고리즘 관련
* int, long 범위
  
## Counting Elements -  PermCheck
* 시간복잡도 : O(N)
* 공간복잡도 : O(N), 배열에 넣어서 체킹하는 방법이 있음
* 첫번쨰 컨셉 : 소팅해두고 차이를 구해둔 채 써치를 돌렸을 때 차이가 아닌 다른 차이값이 나오면 순열이 아니라고 판단 : 퀵소트때문인가 시간초과뜸
* 두번째 컨셉 : 최대값을 구하고, 최대값만큼 배열을 만들고, 주어진 배열을 하나씩 돌면서 나오는 값을 해당 인덱스에 ++ 처리(카운팅 
  * 어차피 1번 밖에 표시안됨), 그러고 넣을 때 첫번째 인덱스값을 계속 갱신해뒀다가 다음 인덱스와의 차이값을 구해둔 뒤에 그 다음 인덱스랑 값이 다르면..(스트림 처리 할 수도)
  * 쉽게 생각하면 됐었다 - 차이가 1인 순열인지 아닌지 체크하는 문제였음
  * 길이보다 뛰어넘는 숫자가 포함되어있을 경우에는 이미 뛰어넘는 숫자가 있다는 가정이 되니깐 false 처리 : 해당 자리가 해당 숫자가 아닐 가능성이 있어서
  * 시작값이 다를 수 있음
  * 등비수열, 등차수열 이런게 아니라 그냥 순열임......;;;
  
* 새로운 시도 : 하지만 체킹을 할 때는 연산보다 배열을 사용해서 체크를 하는게 더 낫다, 범위 벗어날 때도 있고, 예외상황 만드는거 보니 sum은 순열일 때 합이 맞는데 실제로 요소들은 아닌 경우도 있음(하나하나 체크해야)
  
## Counting Elements - FrogRiverOne
* X와 정수 배열이 주어지는데,정수 배열 순회하면서 해당 값이 있는지 체크함
  * 순회했을 때 X값이 없다면 -1을 리턴하면 됨
  * 시간복잡도 : O(N)
  * 공간복잡도 : O(X)
  * 주어지는 배열에는 양수값만 있음 : 그 값이 있는 인덱스를 리턴해야하므로 순서 조작이 있으면 안됨
  * 일치하는 값이 가장 빠르게 건너는 시간인 것 아님? 그떄를 찾아서 리턴하라는 것 같은데
  * 반대편 위치(X + 1)로 가고 싶다함 
  * 인덱스가 곧 n초를 뜻함
  * 아하! X까지의 숫자가 나타났을 때! 그때가 끝, 순서는 상관없이 나오기만 하면 됨!
  * 첫번째 컨셉 : checker를 만든다 -> 그대로하면 for이 중첩되어서 n^2이 되어버린다
     * int[]를 만들면 기본적으로 0으로 초기화되잖아 해당값이 0일 떄는 체킹을 하는데 1이라면 그냥 넘어가기
     
* 두번째 컨셉 : X까지의 합을 구해뒀다가 아...이러면 뭐가 들어왔는지 안들어왔는지 체크하기가 힘들구나
  
# 0501
## 공부한 API, 문법, 생각할 것
* boolean의 default value : false 
* 인덱스와 N번째는 확실히 구분해야한다
    
## 알고리즘 관련
* 시공간 복잡도는 항상 같이 간다 따로따로 아님 : 곧 힌트다
  
## Counting Elements -  MissingInteger
* 배열이 주어지는데 빠진 숫자(양수만)를 찾는 것
  * 음수로 이뤄져있다면 가장 작은 양수(0 아님)를 리턴하면 됨
  * 시간복잡도 : O(N)
  * 공간복잡도 : O(N)
  * 배열 개수는 1..100,000
  * 수 범위는 -1,000,000..1,000,000
  * 주어진다면 순서대로 주어질 듯 : 순열 같은 문제인데 범위가 늘어나서 올 -만 다 뺴면 될 듯
  * - 면 다 넘겨두고, 맥스값 찾아서 체커를 만드는데(0인덱스 무시를 위해 +1) 맥스값이 -인 경우 1개만 만들어서 나중에 체크할 땐 1만 빠졌다고 체크하면 될 듯
  * 발견되지않는 상황과 모두 음수일 때에 대한 처리를 해야함
  * 공간복잡도가 O(N)이므로 N개의 숫자가 주어졌을 때 O(N)까지 체커를 만들어도 상관없음
